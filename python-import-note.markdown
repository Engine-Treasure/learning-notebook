- python的导入方式有以下几种:
 1. 常规导入
 2. from语句导入
 3. 相对导入
 4. 可选导入
 5. 本地导入

- 常规导入就是使用`import xxx`导入模块或包
- python风格指南建议将每个导入语句单独成行,因此导入多个模块或包时,应该这样:

```python
import os
import sys
import time
```

- 可以对导入的模块重命名:`import sys as system`
- 使用`from ... import ...`导入一个模块或包的一部分.与常规导入的区别在于:

```python
from functools import lru_cache
# 可以直接调用 lru_cache

import functools
# 需要 functools.lru_cache
```

- `from os import *`导入模块的全部内容,并且可直接使用.但不建议这样使用,因为可能自定义了一个与该模块同名的函数或变量,会有冲突

- 在复杂代码库中,如果能够看出某个函数是从哪里导入的,或许更有用
- `\`是python中的续行符
- 相对导入,使用句点来决定如何相对导入其他的包或模块.可通过在目录下创建`__init__.py`来管理当前目录下的模块或包
- `from . import module_x`,在`__init__.py`中,表示导入当前目录目录下的`module_x`模块
- `from .module_y import spam`表示从当前目录下的`module_y`模块,导入spam.可用于同一目录下的不同模块之间的导入
- 相对导入适用于组织放入包中的代码.但导入的层数不宜过深
- 若在包中的某个模块中添加`if __name__=="__name__":`,然后以脚本模式运行,将报错.即相对导入不支持脚本模式运行包中的某一模块
- 将使用相对导入组织的包或模块的路径添加至python的导入索引路径,之后就可以方便的使用该包或模块了
- 使用`try ... except ...`语句,可实现可选导入.这将优先导入`try`之后的模块,若出错(比如模块不存在),将导入`except`后的模块
- 模块也有作用域,放在脚本文件的顶部,即表示导入至全局作用域.在类或函数的局部作用域导入模块,该模块就只能在类或函数中使用.
- 但按照约定,所有的导入语句都应该位于模块的顶部
- 导入模块时,python将首先在脚本所在目录下查找.因此自定义模块与其他内建或第三方模块重名时,将优先导入当前目录下的模块.这可能会引发错误
- 
