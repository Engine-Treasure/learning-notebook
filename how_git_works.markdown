# 从原理的角度看Git

- [工作区 远程仓库] -> [工作区 本地仓库 远程仓库] -> [工作区 暂存区 本地仓库 远程仓库]
- 加入暂存区的原因：
 1. 为了实现部分提交
 2. 为了不在工作区创建状态文件，会污染工作区
 3. 暂存区记录文件的修改时间等信息，提高文件比较的效率
- 以快照的方式进行版本管理，避免相同文件的多个备份
- 利用sha-1算法，以文件的sha-1值作为文件的唯一id，并提供检验。
 1. 由文件内容计算出hash值
 2. hash值相同，文件内容相同
- .git/objects目录下，利用sha-1的前2位创建目录，剩余38位作为文件名，这些文件保存了提交的记录。
- 四类obj文件：
 1. blob - 用来存放项目文件的内容，但补包括文件路径、文件名、格式等其他描述信息。项目的任意文件的任意版本都已blob形式存放
 2. tree - 表示目录。一个项目就是一个目录，目录中有文件、子目录。因此，tree中有blob、子tree，都以sha-1值引用，与目录对应。顶层的tree对象代表当前项目的快照。
 3. commit - 表示一个提交，有parent字段，用来引用父提交。指向顶层tree时，表示了项目的快照
- 暂存区用文件`.git/index`表示，文件内容的第二列sha-1 hash值是实际存储文件内容的blob，第三列是冲突状态，第四列是文件路径名。
- 当提交时，git会将暂存区的信息生成tree对象，即项目快照。
- 可以说暂存区是用来构建项目快照的区域。
- 文件状态有2类，一类是暂存区与本地仓库比较得出的状态，一类是工作区与暂存区比较得出的状态。执行`git status`命令时，看到的绿色与红色就分别对应这两种状态。
- 分支的目的是为了并行地开发。
- `.git/HEAD`文件保存了当前分支。实际上打开`.git/HEAD`文件看到的`ref`表示的就是一个分支，只是用`HEAD`再包装了。
- git中，分支是指向一个提交的指针。
- 每次将修改的文件加入到暂存区，git 都会根据文件的内容计算出 sha-1，并将内容转换成 blob，写入数据库。然后使用 sha-1 值更新该列表中的文件项。在暂存区的文件列表中，每一个文件名，都会对应一个sha-1值，用于指向文件的实际内容。最后提交的那一刻，git会将这个列表信息转换为项目的快照，也就是 tree 对象。写入数据库，并再构建一个commit对象，写入数据库。然后更新分支指向。
- 每次提交都包含了项目完整的快照，合并只是tree与tree的合并。
- 比较2个分支，选取分歧点作为参考点
- 合并是将一条分支合并到另一条分支，一条当前分支，一条要合并的分支。因此，分支冲突状态可以有4种定义：
 1. DELETED_BY_THEM
 2. DELETED_BY_US
 3. BOTH_ADDED
 4. BOTH_MODIFIED
- 遇到不可自动合并冲突时，git将状态写入暂存区。
- git用1，2，3标记文件，1表示文件的base版本(分歧点的版本)，2表示当前分支的版本，3表示要合并分支的版本
- `merge` - 将修改的内容作为新的提交，合并之后，会在目标分支提交一个新的commit。两条分支还是两条分支。
- rebase` - 将分歧点以来的所有提交，以补丁的方式一个个打到目标分支上。两条分支变为一条分支。`rebase`会修改分支的历史提交。若将`rebase`的分支推送到了远程仓库，将导致无法将修改的分支推送上去。应避免在公共分支上进行操作。
- `checkout`的工作步骤：
 1. 找到目标提交，目标提交中的tree对象是要检出的项目版本
 2. 根据tree生成暂存区内容，将tree和blob转换成项目文件
 3. 修改HEAD指向，切换分支
- 反向提交：在旧版本中添加了的内容，要在新版本中删除；旧版本中删除了的内容，要在新版本中添加
- `revert` - 检索出目标提交的项目快照到工作区和暂存区，用新的提交完成版本“回退”？不修改提交历史
- `reset` - 在当前分支上进行版本“回退”，修改提交历史
 - soft - 仅仅修改分支指向，不修改工作区和暂存区内容
 - mixed - 比soft的作用于多了一个暂存区
 - hard - 比mixed多了一个工作区，会导致工作区内容的“丢失”
- `stash` - 将工作区和暂存区的内容做一个提交，用`reset hard`恢复工作区和暂存区内容，回退到某个版本。之后可用`stash apply`回来。
- `bisect`在历史版本与出错版本间进行二分查找，找出bug所在
