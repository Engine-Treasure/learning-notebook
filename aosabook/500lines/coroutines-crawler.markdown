# 基于协程的网络爬虫

- 默认地, socket 操作是阻塞的
- 同于同步 IO, 多线程存在缺陷
- `连接`时, 非阻塞线程会抛出一个异常, 即使正常工作的情况下. 这是因为底层的 C 代码, 其为 `EINPROGRESS` 设置 `errno` 来告诉用户, 连接开始了
- 旧时, 对于循环等待的解决方案是, `select` - 等待一个或一小组非阻塞 socket 上的时间发生.
- 如今的解决方案是, `poll`, 或 BSD 的 `kqueue`, 或 Linux 上的 `epoll`. 接口与 `select` 类似, 但性能更好, 能支持更多的连接
- Python 3.4 的 `DefaultSelector` 会选择当前系统中最佳的类 `select` 函数
- 异步框架由两个功能构成: 非阻塞 socket, 事件循环. 实现在一个单线程上执行同步操作
- 异步并不比多线程快. 异步 IO 适合的场景是, 有许多缓慢或休眠的连接, 事件发生得并不频繁
- 抓取页面需要一系列的回调. 当 socket 连接到服务器时, 触发 `connected` 回调函数, 向服务器发送 GET 请求; 注册另一个回调以等待响应; 当无法读取完整的响应时, 又是一个回调, 等等
- 所有事件通知都在调用 `select` 时, 在事件循环中处理
- 真实情况下, 需要检查 `send` 函数的返回值. 因为整个消息可能不能一次性发送完毕
- 异步编程的一个好处是, 不必使用互斥锁来分享数据
