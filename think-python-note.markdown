# Think Python Notes

[TOC]

## Chapter 1

- 对计算机科学家,最重要的技能是解决问题的能力.解决问题意味着对问题进行形式化,寻求创新性的解决方案,并且清晰,准确地表达解决方案的能力
- `^`在python中作为异或运算符XOR
- `type()`查看值的类型
- 形式语言(formal languages)是人类为了特殊用途而设计的,数学符号,化学符号,编程语言等都是
- 语法规则有2种类型,分别设计记号与结构.记号是语言的基本元素,结构则与记号的组合方式有关.理清语句的结构的过程称为解析(parsing)

## Chapter 2

- 编程语言最大的特性之一,是操作变量的能力.变量是指向某值的名称
- 变量名,表达式,语句
- 在注释中记录代码不明显的特征,解释代码为什么这么做更有用.显而易见的东西就没必要再注释了
- 语法是指程序的结构及其背后的规则,语法错误,python会提示;运行时错误,只在程序开始运行之后出现,也称异常;语义错误,与程序的意思有关,程序运行时不会产生错误信息,但不会返回正确结果- 字符串的`+`,`*`操作
 
## Chapter 3

- 编程的语境下,函数是指一个有命名的,执行某个计算的语句序列
- `int`转化浮点数时,只截掉小数部分
- 模块指一个含有相关函数的文件
- 点标记法,调用模块中的函数,`模块名.函数名`
- 编程语言的特征之一是`组合规则`,将小块构建材料组合在一起,几乎任何可以放置的地方,都可以放表达式,但赋值语句的左侧必须是变量名
- 定义一个函数创建一个函数对象,其类型是`function`
- 在函数内部,实参赋给形参,实参名与形参名没有任何关系
- 变量与形参都是局部的.在所有函数以外创建变量,它就属于`__main__`
- 无返回值函数,实际返回了一个`None`
- `print`会自动换行

## Chapter 4 案例研究: 接口设计

- 将一部分代码包装在函数里被称作封装(encapsulaton).好处是为这些代码赋予了一个名字,实现了特定功能;另外实现了代码的复用
- 调用函数时,用关键字实参,可以忽略参数顺序
- 函数的接口（interface）是一份关于如何使用该函数的总结： 形参是什么？函数做什么？返回值是什么？ 如果接口让调用者避免处理不必要的细节，直接做自己想做的事，那么这个接口就是“干净的”。
- 重新整理一个程序以改进函数接口和促进代码复用的这个过程， 被称作重构（refactoring）.在一个项目开始的时候，你常常并不知道那么多，不能设计好全部的接口。 一旦你开始编码后，你才能更好地理解问题。 有时重构是一个说明你已经学到某些东西的预兆。
- 接口就像是函数和调用者之间的合同。 调用者同意提供合适的参数，函数同意完成相应的工作。

## Chapter 5 条件和递归

- `//` - 地板除(floor division), 先除, 后将结果保留到整数
- `%` - 取余. 还可以理解成取一个数最右边的n位数(模10^n)
- 在python3中, 任何类型的`/`运算都会保留小数部分
- 任何非0的数字都被解释成True
- 嵌套条件阅读不太方便, 应避免. 逻辑运算符(and, or, not)是一个简化嵌套条件语句的方法
- python的递归上限大概是1000
- 递归终止条件很重要
- `input` - 暂停程序运行, 等待用户输入, 等用户输入`enter`后, 继续执行. 以字符串形式返回用户输入. 接受提示语作为实参
- 通常, 错误信息最有用的部分: 错误类型, 错误发生的地点
- 通常，错误信息指向发现错误的地方， 但是实际的错误可能发生在代码中更早的地方
- `time.time()`返回一个时间戳

## Chapter 6 有返回值的函数

- 调用一个有返回值的函数会生成一个返回值，我们通常将其赋值给某个变量或是作为表达式的一部分。
- 空函数返回`None`, 其作用往往是产生某个行为; 而有返回值的函数, 更多的是为了得到结果
- 出现在某条return语句之后的代码，或者在执行流程永远不会到达之处的代码，被称为死代码（dead code）
- `增量式开发`, 通过每次只增加和测试少量代码，来避免长时间的调试\\
一开始的时候最好每次只输入一二行代码
- `手脚架代码`, 在调试时很有用, 对程序的构建有用, 但不是最终产品的一部分
- `增量式开发`的关键:
 1. 从一个能运行的程序开始，并且每次只增加少量改动。无论何时遇到错误，都能够清楚定位错误的源头。
 2. 用临时变量存储中间值，这样就能显示并检查它们。
 3. 一旦程序正确运行，你要删除一些脚手架代码，或者将多条语句组成复合表达式，但是前提是不会影响程序的可读性。
- 临时变量对开发调试很有用, 但一旦函数正确运行了, 就可通过合并函数调用, 使程序更简洁
- 布尔函数, 通常对隐藏函数内部的复杂测试代码很方便
- 跟随程序执行流程是阅读程序代码的一种方法，但它可能很快会变得错综复杂
-  有另外一种替代方法“信仰之跃”。 当遇到一个函数调用时，不再去跟踪执行流程，而是假设这个函数正确运行并返回了正确的结果。
- 对函数的输入参数进行检测, 保证代码的正确性
- `调试`. 将一个大程序分解为较小的函数为调试生成了自然的检查点。 如果一个函数不如预期的运行，有三个可能性需要考虑：
 1. 该函数获得的实参有些问题，违反先决条件。
 2. 该函数有些问题，违反后置条件。
 3. 返回值或者它的使用方法有问题。
- 如果对执行流程感到困惑，开发有效的脚手架代码。

## Chapter 7 迭代

- `相等`是一种对称关系, `赋值`不是. 因此`==` != `=`
- 在更新变量之前, 必须先**初始化**
- 计算机很擅长无纰漏地重复相同或类似的任务. 在计算机程序中, 重复称为`迭代`
- `递归迭代`, `for迭代`, `while迭代`
- `牛顿法`求平方根: $\frac{x + ]frac{a}{x}}{2}$, 迭代多次, 估计越准确
- 检查浮点数是否相等是危险的事, 因为大多数浮点数不能精确表示. 一个代替的方法是, 检查两个浮点数的差是否小于一个极小值:

```python
if abs(y - x) < epsilon:
    break
```

- 99乘法表不是算法, 但列竖式求积是算法
- 算法的特点之一是不需要过多的脑力计算, 是一个机械的过程, 每一步都依据简单的规则跟着上一步来执行
- `对分调试`

## Chapter 8 字符串

- 字符串是一个序列
- 切片
- 字符串是不可变的. 更新字符串的方法之一: 新的字符串 + 切片. 但这是获得了一个新的字符串, 并不影响源字符串
- `find`接收一个字符(或子串),  返回该字符(或子串的第一个字符)的索引. 若未找到, 返回-1
- `find(str[, st[, end]])
- `in`作为一个布尔运算符, 判断第一个str是否存在于第二个str中
- 字符串比较, `==`检查是否相等, `<`, `>`等按字典需比较
- 当使用索引遍历序列中的值时，正确地指定遍历的起始和结束点有点困难, 可打印出来看看
