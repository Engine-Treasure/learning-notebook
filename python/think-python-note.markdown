# Think Python Notes

[TOC]

## Chapter 1

- 对计算机科学家,最重要的技能是解决问题的能力.解决问题意味着对问题进行形式化,寻求创新性的解决方案,并且清晰,准确地表达解决方案的能力
- `^`在python中作为异或运算符XOR
- `type()`查看值的类型
- 形式语言(formal languages)是人类为了特殊用途而设计的,数学符号,化学符号,编程语言等都是
- 语法规则有2种类型,分别设计记号与结构.记号是语言的基本元素,结构则与记号的组合方式有关.理清语句的结构的过程称为解析(parsing)

## Chapter 2

- 编程语言最大的特性之一,是操作变量的能力.变量是指向某值的名称
- 变量名,表达式,语句
- 在注释中记录代码不明显的特征,解释代码为什么这么做更有用.显而易见的东西就没必要再注释了
- 语法是指程序的结构及其背后的规则,语法错误,python会提示;运行时错误,只在程序开始运行之后出现,也称异常;语义错误,与程序的意思有关,程序运行时不会产生错误信息,但不会返回正确结果- 字符串的`+`,`*`操作

## Chapter 3

- 编程的语境下,函数是指一个有命名的,执行某个计算的语句序列
- `int`转化浮点数时,只截掉小数部分
- 模块指一个含有相关函数的文件
- 点标记法,调用模块中的函数,`模块名.函数名`
- 编程语言的特征之一是`组合规则`,将小块构建材料组合在一起,几乎任何可以放置的地方,都可以放表达式,但赋值语句的左侧必须是变量名
- 定义一个函数创建一个函数对象,其类型是`function`
- 在函数内部,实参赋给形参,实参名与形参名没有任何关系
- 变量与形参都是局部的.在所有函数以外创建变量,它就属于`__main__`
- 无返回值函数,实际返回了一个`None`
- `print`会自动换行

## Chapter 4 案例研究: 接口设计

- 将一部分代码包装在函数里被称作封装(encapsulaton).好处是为这些代码赋予了一个名字,实现了特定功能;另外实现了代码的复用
- 调用函数时,用关键字实参,可以忽略参数顺序
- 函数的接口（interface）是一份关于如何使用该函数的总结： 形参是什么？函数做什么？返回值是什么？ 如果接口让调用者避免处理不必要的细节，直接做自己想做的事，那么这个接口就是“干净的”。
- 重新整理一个程序以改进函数接口和促进代码复用的这个过程， 被称作重构（refactoring）.在一个项目开始的时候，你常常并不知道那么多，不能设计好全部的接口。 一旦你开始编码后，你才能更好地理解问题。 有时重构是一个说明你已经学到某些东西的预兆。
- 接口就像是函数和调用者之间的合同。 调用者同意提供合适的参数，函数同意完成相应的工作。

## Chapter 5 条件和递归

- `//` - 地板除(floor division), 先除, 后将结果保留到整数
- `%` - 取余. 还可以理解成取一个数最右边的n位数(模10^n)
- 在python3中, 任何类型的`/`运算都会保留小数部分
- 任何非0的数字都被解释成True
- 嵌套条件阅读不太方便, 应避免. 逻辑运算符(and, or, not)是一个简化嵌套条件语句的方法
- python的递归上限大概是1000
- 递归终止条件很重要
- `input` - 暂停程序运行, 等待用户输入, 等用户输入`enter`后, 继续执行. 以字符串形式返回用户输入. 接受提示语作为实参
- 通常, 错误信息最有用的部分: 错误类型, 错误发生的地点
- 通常，错误信息指向发现错误的地方， 但是实际的错误可能发生在代码中更早的地方
- `time.time()`返回一个时间戳

## Chapter 6 有返回值的函数

- 调用一个有返回值的函数会生成一个返回值，我们通常将其赋值给某个变量或是作为表达式的一部分。
- 空函数返回`None`, 其作用往往是产生某个行为; 而有返回值的函数, 更多的是为了得到结果
- 出现在某条return语句之后的代码，或者在执行流程永远不会到达之处的代码，被称为死代码（dead code）
- `增量式开发`, 通过每次只增加和测试少量代码，来避免长时间的调试\\
一开始的时候最好每次只输入一二行代码
- `手脚架代码`, 在调试时很有用, 对程序的构建有用, 但不是最终产品的一部分
- `增量式开发`的关键:
 1. 从一个能运行的程序开始，并且每次只增加少量改动。无论何时遇到错误，都能够清楚定位错误的源头。
 2. 用临时变量存储中间值，这样就能显示并检查它们。
 3. 一旦程序正确运行，你要删除一些脚手架代码，或者将多条语句组成复合表达式，但是前提是不会影响程序的可读性。
- 临时变量对开发调试很有用, 但一旦函数正确运行了, 就可通过合并函数调用, 使程序更简洁
- 布尔函数, 通常对隐藏函数内部的复杂测试代码很方便
- 跟随程序执行流程是阅读程序代码的一种方法，但它可能很快会变得错综复杂
-  有另外一种替代方法“信仰之跃”。 当遇到一个函数调用时，不再去跟踪执行流程，而是假设这个函数正确运行并返回了正确的结果。
- 对函数的输入参数进行检测, 保证代码的正确性
- `调试`. 将一个大程序分解为较小的函数为调试生成了自然的检查点。 如果一个函数不如预期的运行，有三个可能性需要考虑：
 1. 该函数获得的实参有些问题，违反先决条件。
 2. 该函数有些问题，违反后置条件。
 3. 返回值或者它的使用方法有问题。
- 如果对执行流程感到困惑，开发有效的脚手架代码。

## Chapter 7 迭代

- `相等`是一种对称关系, `赋值`不是. 因此`==` != `=`
- 在更新变量之前, 必须先**初始化**
- 计算机很擅长无纰漏地重复相同或类似的任务. 在计算机程序中, 重复称为`迭代`
- `递归迭代`, `for迭代`, `while迭代`
- `牛顿法`求平方根: $\frac{x + ]frac{a}{x}}{2}$, 迭代多次, 估计越准确
- 检查浮点数是否相等是危险的事, 因为大多数浮点数不能精确表示. 一个代替的方法是, 检查两个浮点数的差是否小于一个极小值:

```python
if abs(y - x) < epsilon:
    break
```

- 99乘法表不是算法, 但列竖式求积是算法
- 算法的特点之一是不需要过多的脑力计算, 是一个机械的过程, 每一步都依据简单的规则跟着上一步来执行
- `对分调试`

## Chapter 8 字符串

- 字符串是一个序列
- 切片
- 字符串是不可变的. 更新字符串的方法之一: 新的字符串 + 切片. 但这是获得了一个新的字符串, 并不影响源字符串
- `find`接收一个字符(或子串),  返回该字符(或子串的第一个字符)的索引. 若未找到, 返回-1
- `find(str[, st[, end]])
- `in`作为一个布尔运算符, 判断第一个str是否存在于第二个str中
- 字符串比较, `==`检查是否相等, `<`, `>`等按字典需比较
- 当使用索引遍历序列中的值时，正确地指定遍历的起始和结束点有点困难, 可打印出来看看

## Chapter 9 文字游戏

- `readline` - 从文件对象中读取字符直到新行, 并并将结果作为字符串返回
- 搜索优化的过程：

```python
def has_no_e(word):
    if 'e' in word:
        return False
    return True
```

```python
def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
```

```python
def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
```

```python
def uses_all(word, required):
   for letter in required:
       if letter not in word:
           return False
    return True
```

```python
def uses_all(word, required):
    return uses_only(required ,word)
```

- 如上代码所示, `has_not_e`只能判断字母`e`在不在单词里, 而`avoids`则可以判断任意禁用字符是否在单词里出现, 更优. `uses_only`与`uses_all`则相反, 它们是判断单词是否全由指定字符集中的字符构成, 不过判断方式有所不同. 实现`uses_all`或`uses_only`其中一个, 另一个可以简单写出, 如最后一个函数所示
- 测试能帮助你找到错误， 但是生成好的测试用例并不容易， 并且即便你做到了，你仍然不能保证你的程序是正确的
- 程序测试能用于展示错误的存在，但是无法证明不存在错误！ -- Edsger W. Dijkstra

## Chapter10 列表

- python中的变量名是对对象的引用, 一个list名相当于引用的应用. 列表名指向列表对象, 列表名+列表中的索引又指向实际的列表元素对象
- 尽管一个列表可以包含另一个列表，嵌套的列表本身还是被看作一个单个元素
- 同str一样, list的`+`操作是拼接, `*`操作是重复
- 切片是序列的部分或全部拷贝
- `append`, 追加元素
- `extend`, 接受一个iterable作为参数, 将其中的所有元素添加到目标列表(用列表扩展列表)
- `sort`, 排序
- 将一系列的元素合并成一个单一值的操作有时称为 归并（reduce）, `sum`是一个具体功能的`reduce`
- `map`, 将一个函数或操作作用于iterable的每个元素
- `filter`, 筛选, 选中一些, 剔除一些
- `pop`, 我更倾向于解释成弹出, 而非删除, 因为可取得弹出的值. 与c++不同, python的`pop`可指定position, 默认是尾元素
- `del`才是真正的删除, 不会获得删除的值. `del t[1]` 删除一个; 或`del t[1:5]` 删除一片
- `remove`的参数是值, 而非索引. 返回值为`None`
- str的`split`默认使用空格作为分隔符
- `join`与`split`功能恰恰相反, 用于将字符串的序列拼接起来. 但用法有点奇怪.`分隔符.join(字符串序列)`
- `is`, 可以用于比较, 有点像java的全等. 更科学的说法是, `a=b`, 表示a与b相等, `a is b`表示a与b相同
- 一个对象拥有一个值, 我们常常不严谨地说, 两个对象相同或相等, 可能是指它们的值相等, 但它们不是同一个对象
- 变量和对象之间的关联称为`引用`.
- 将列表作为参数传入函数时, 传递就是引用, 因此在函数对列表的修改是真实的
- **需要注意修改操作与创建操作的区别**. `append`方法修改一个列表, 返回`None`, 但`+`运算是创建一个新的列表
- 切片运算创建了一个新的列表, 对新列表的修改, 不会影响原列表
- 调试
 - 大多数列表方法会对参数进行修改, 返回`None`; 而字符串由于是不可变的, 实际是返回了一个新的字符串
 - 列表的添加或删除操作是多样的, 最好选择一种, 坚持

## Chapter11 字典

- 在列表中，索引必须是整数；但在字典中，它们可以是（几乎）任何类型.
- 对于字典, `in`操作符用于检查`key`是否存在; 检查`value`是否存在, 可先用`values()`方法取得value的集合(`dict_values`类型)
- 随着列表的增长，搜索时间成正比增长。
- 字典, Python使用`hashtable`实现, 无论有多少项, `in`运算符的搜索时间几乎一样
- 黑猫白猫, 能抓到老鼠的就是好猫, 有些猫可能抓老鼠效率更高呢
- 字典的`get`方法, 返回key对应的值, 或默认值
- 通过`key`取得对应的`value`, 称为查找; 通过`value`查找`key`的过程称为**逆向查找**, 其难点在于:
 1. 可能有不止一个的键其映射到值v
 2. 没有内建的逆向查找方法.
- `sorted(dict)`返回排序后的key的列表
- 哈系函数接受一个任意类型的值, 并返回一个整数. 字典的key是可哈系的
- 字典可变的
- 一些程序使用`verbbose`作标记, 控制输出的丰富程度
- 要函数内部使用全局变量, 需要用`global`关键字声明. 否则会自动创建当前作用域的临时变量
- 如果全局变量是可变的, 可以不加声明地修改
- 对不可修改类型的变量, 修改, 实际就是创建了新的对象, 再附给变量:

```python
In [1]: a=1

In [2]: id(a)
Out[2]: 10105824

In [3]: a+=1

In [4]: id(a)
Out[4]: 10105856

In [5]: a=[1,2]

In [6]: id(a)
Out[6]: 139665751113544

In [7]: a.append(3)

In [8]: id(a)
Out[8]: 139665751113544
```

- 调试:
 - 缩小输入 - 减小数据集合的大小
 - 检查摘要和类型 - 有时候出错可能是类型不对, 因此打印类型就够了
 - 编写自检代码 - 合理性检查, 或一致性检查
 - 格式化输出 - `pprint`模块的`pprint`函数, 可以更可读的格式显示内建类型

## Chapter12 元组

- 单元素元组, 必须在结尾加逗号

```python
tuple('lupins')
('l', 'u', 'p', 'i', 'n', 's')
```

- 关系型运算符也适用于元组和其他序列, 会按序比较:

```python
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
```

- 元组赋值, 优雅地集体赋值方式
- 严格地说，一个函数只能返回一个值，但是如果返回值是元组，其效果等同于返回多个值
- 以 `*` 开头的形参将输入的参数 汇集 到一个元组中; 对实参使用`*`可以将一个值序列打散, 作为多个参数传递给函数
- `zip`, 原来来自于名词`zipper`(拉链). 这样它的功能就好理解多了
- 将`zip`和`for`连用, 是遍历2个序列的惯用方法:

```python
In [13]: a = [1,2,3,4]

In [14]: b = [5,6,7,8]

In [15]: for a_i, b_i in a, b:
....:     print(a_i, b_i)
....:
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-15-710baf754875> in <module>()
----> 1 for a_i, b_i in a, b:
      2     print(a_i, b_i)
      3
ValueError: too many values to unpack (expected 2)

In [16]: for a_i, b_i in zip(a, b):
    print(a_i, b_i)
    ....:
1 5
2 6
3 7
4 8
```

- 字典的`items()`方法, 返回多个元组组成的序列, 每个元组都是一个键值对. 但返回值实际是`dict_iterms`对象
- 可以用元组的列表初始化新的字典: `dict(zip('abc', range(3)))`
- 用元组作为字典的key
- 调试:
 - 复合数据结构实用, 但容易引起形状错误(shape errors), 即由于数据结构的类型, 大小或结构问题引发的错误

## Chapter13 案例研究: 数据结构选择

-  伪随机数不是真正的随机数，因为它们由一个确定性的计算生成， 但是仅看其生成的数字，不可能将它们和随机生成的相区分开。
- `random.random()` - 返回一个[0.0, 1.0)的随机浮点数
- `random.randint(low, high)` - 返回[low, high]的整数
- `马尔科夫`分析
- 调试:
 - 细读
 - 运行 - 通过修改和运行不同版本来试验
 - 思考 - 错误的类型, 问题出现前最后的修改
 - 小黄鸭调试法(rubberducking) - 将问题解释给自己听
 - 回退

## Chapter14 文件

- `持久化`
- `write`方法的放回值是写入字符的个数.
- 文件对象自动跟踪自身的位置, 下次调用读写时, 从前一次结束的位置开始
- 对于数字类型, `%`是取模运算符, 但当第一个运算数是字符串时, `%`是格式化运算符. 格式化字符串可包含一个或多个格式化序列, 格式化序列指定了第二个运算数是如何格式化, 运算结果为一个字符串
- 如果字符串中有多个格式化序列，那么第二个参数必须是一个元组。 每个格式化序列按顺序和元组中的元素对应。
- `%d` - 格式化整数
- `%g` - 格式化浮点数
- `%s` - 格式化字符串
- `os.getcwd()` - 返回当前目录的路径
- `os.path.abspath()` - 获得文件的绝对路径
- `os.path.exists()` - 检查文件或目录是否存在
- `os.path.isdir()` - 检查是否目录
- `os.path.isfile()` - 检查是否文件
- `os.listdir()` - 返回给定目录下的文件列表
- `os.path.join()` - 接收一个目录和文件名, 拼接成完整路径
- `dbm`模块提供了创建和更新数据库文件的接口
- 大多数的数据库采用类似字典的形式，即将键映射到值
- `dbm.open()` - 打开数据库文件, 返回一个数据库对象, 可以像字典样使用
- `dbm`的一个限制是key与value必须是字符串或字节
- `pickle`模块提供了将几乎所有类型的对象转化为适合在数据库中存储的字符串，以及将那些字符串还原为原来的对象的功能
- `pickle.dumps`(dump string)读取一个对象作为参数，并返回一个字符串表示 - 序列化
- `pickle.loads`(load string)可以重建对象 - 反序列化
- 任何可以在shell中启动的程序，也可以在 Python 中通过使用 管道对象（pipe object） 来启动。一个管道代表着一个正在运行的程序。
- `os.popen` - 接收参数为shell命令的字符串, 返回值为一个行为类似打开文件的对象. 使用完毕, 要关闭
- 任何包含 Python 代码的文件，都可以作为模块被导入
- `__name__`是一个在程序开始时设置好的内建变量.  如果程序以脚本的形式运行，`__name__` 的值为 `__main__`
- 如果你导入一个已经被导入了的模块，Python 将不会做任何事情。它并不会重新读取文件，即使文件的内容已经发生了改变。
- 调试:
 - `repr()`函数接受任意一个对象作为参数，然后返回一个该对象的字符串表示. 调试时好用
