- Akka is an actor-based message-driven runtime for managing concurrency (同步), elasticity (弹性) and resilience (恢复力, 弹力) on the JVM with support for both Java and Scala.
- Akka 中, 服务之间的通信使用消息原语 (primitive) 来优化 CPU 的利用 (utilization), 低延迟 (low latency), 高吞吐量 (high throughput), 可伸缩性 (scalability).

## Actor 系统

- Actor是封装状态和行为的对象，他们唯一的通讯方式是交换消息——把消息存放在接收方的邮箱里。
- 程序中负责某一功能的actor，可能需要把它的任务分拆成更小的、更易管理的部分, 为此它启动子actor并监督它们。每个actor有且仅有一个监管者，就是创建它的那个actor。
- Actor系统的精髓在于任务被拆开、委托，直到任务小到可以被完整地处理。这样做不仅清晰地划分出了任务本身的结构，而且最终的actor也能按照它们“应该处理什么类型的消息”，“如何处理正常流程”以及“如何应对失败流程”来进行推理。
- 分层的设计方法最终很容易形成防护性编程，以防止任何失败被泄露出来
- 父 actor 监督 子 actor, 父actor知道可能会出现哪些失败情况，以及如何处理它们。
- 如果一个actor携带着重要数据（即它的状态要尽可能地不被丢失），这个actor应该将任何可能出现危险的子任务分配给它所监管的子actor，并酌情处理子任务的失败。根据请求的性质，可能的话最好为每一个请求创建一个子actor，这样能简化收集回应的状态管理。这在Erlang中被称为“Error Kernel Pattern”。
- actor 最佳实践:
    - 以事件驱动的方式来处理事件并生成响应, 不应该因为某个外部实体而阻塞
    - 不要在 actor 之间传递可变对象. 为了保证这一点，选择不可变消息。如果actor将他们的可变状态暴露给外界，打破了封装，你就回到了普通的Java并发领域并遭遇其所有缺点。
    - 不要在消息中传递行为
    - 顶级actor在错误内核最深处，所以尽量少创建它们并且选择真正的树形分层系统。
- 对于阻塞问题的建议:
    - 在一个 actor 内进行阻塞调用, 并确保配置一个线程池，它要足够大或者专门用于这一目的。
    - 在一个 `Future` 内进行阻塞调用，确保任意时间点内这种调用的数量都在一个上限内
    - 在一个 Future 内进行阻塞调用，使用一个线程池，该线程池的线程数上限对应用程序运行的硬件是合适的。
    - 奉献一个单独的线程来管理一组阻塞资源, 并在事件发生时把它们作为actor消息发送。
- 一个actor系统管理它所配置使用的资源，运行它所包含的actor。 在一个系统中可能有上百万个actor，每个actor实例仅占差不多300个字节。

## 什么是 Actor

- 一个Actor是一个容器，它包含了状态，行为，一个邮箱，子Actor和一个监管策略。所有这些封装在一个Actor引用里.
- 一个actor对象需要与外界隔离开才能从actor模型中获益。因此actor是以actor引用的形式展现给外界的，actor引用作为对象，可以被无限制地自由传递
- 行为是一个函数，它定义了在某个时间点处理当前消息所要采取的动作, 行为可能随着时间而改变.
- Actor的目的是处理消息, 连接发送者与接收者的纽带是actor的邮箱：每个actor有且仅有一个邮箱，所有的发来的消息都在邮箱里排队。
- Akka与其它actor模型实现的一个重要区别在于：当前的行为总是必须处理下一个从队列中取出的消息，Akka不会扫描邮箱队列来获取下一个匹配的消息。
- 父 actor 创建了子actor来委托处理子任务，会自动地监管它们, 子 actor 列表维护在actor的上下文中. 对列表的更改是通过创建(`context.actorOf(...)`)或者停止(`context.stop(child)`)来完成，并且这些更改会立刻生效
- 策略是actor系统组织结构的基础，所以一旦actor被创建，它就不能被修改. 对每个actor只有唯一的策略，这意味着：如果一个actor的子actor们应用了不同的策略，则这些子actor应该按照相同的策略来进行分组，并放在一个中间的监管者下
- 当一个actor终止——即失败了且不能用重启来解决、停止它自己或者被它的监管者停止——它会释放其资源，将其邮箱中所有未处理的消息放进系统的“死信邮箱(dead letter mailbox)”，即将所有消息作为死信重定向到事件流中, 所有新消息作为死信重定向到事件流中.

## 监督与监控

- 监管描述的是 actor 之间的依赖关系: 监管者将任务委托给下属，并相应地对下属的失败状况进行响应。
- Actor类的preRestart钩子（hook）缺省行为是在重启前终止它的所有下属，但这个钩子可以被重写；对所有子actor的递归重启操作在这个钩子之后执行。
- 监管是为了组建一个递归的失败处理结构。如果你试图在某一个层次做太多事情，这个层次会变得复杂并难以理解，因此推荐的方法是增加一个监管层次。
- 监管相关的父-子沟通，使用了特殊的系统消息及其固有的邮箱，从而和用户消息隔离开来, 监管相关的事件相对于普通消息没有确定的顺序关系
- `/system` 的引入是为了实现正确的关闭顺序即日志（logging）要保持可用直到所有普通actor终止，即使日志本身也是用actor实现的.
- actor 处理消息失败的原因有 3 类:
    - 对收到的特定消息的系统错误（即程序错误）
    - 处理消息时一些外部资源的（临时性）失败
    - actor内部状态崩溃了
- 除非故障能被专门识别，否则所述的第三个原因不能被排除，从而引出内部状态需要被清除的结论。如果监管者确定它的其他子actor或本身不会受到崩溃的影响, 最好只重启这个孩子. 具体实现是通过建立底层Actor类的新实例，并用新的ActorRef更换故障实例
- `OneForOneStrategy` 与 `AllForOneStrategy`, 前者只将所获得的指令应用在发生故障的子actor上，而后者则是应用在所有孩子上. 默认是用前者, 通常情况下也应该使用前者.
- `AllForOneStrategy`适用的情况是，子actor之间有很紧密的依赖，以至于一个actor的失败会影响其他孩子

## Actor 引用, 路径与地址

- Actor引用是 ActorRef 的子类，其最重要的目的是支持向它所代表的actor发送消息。
- 通过 `self` 访问自己的标准（本地）引用；在给其它actor发送的消息中也缺省包含这个引用
- 在消息处理过程中, 通过 `sender()` 方法访问当前消息发送者的引用
- Actor引用标明了一个actor，其生命周期和actor的生命周期保持匹配；actor路径表示一个名称，其背后可能有也可能没有真实的actor，而且路径本身不具有生命周期，它永远不会失效.
- 可以创建一个 actor 路径, 而无需创建一个 actor, 但不能在创建 actor 引用时创建相应的 actor
- 可以创建一个actor，终止它，然后创建一个具有相同路径的新actor。新创建的实例是actor的一个新的化身。它并不是一样的actor。一个指向老的化身的actor引用不适用于新的化身。发送给老的actor引用的消息不会被传递到新的化身，即使它们拥有相同的路径。
- 顺着actor的父监管链一直到根的唯一路径被称为actor`逻辑路径`。这个路径与actor的创建祖先关系完全吻合，
- 从actor对象实际所在的actor系统的根开始, 是 actor 的`物理路径`. 物理路径的一个重要性质是它决不会跨多个actor系统或跨JVM虚拟机。
- 获取 actor 引用的 2 种方法:
    1. 创建 actor: `ActorSystem.actorOf` 或 `CActorContext.actorOf`
    2. 查找 actor
        1. 通过具体的 actor 路径来创建 actor 引用: `ActorSystem.actorSelection` (绝对路径), `ActorContext.actorSelection` (相对路径, `..` 访问父 actor, 同 Unix 的路径)
        2. 查询 actor 逻辑树: actorSeletion + 通配符
- `ActorRef`的相等性与`ActorRef`的目的匹配，即一个ActorRef对应一个目标actor化身。两个actor引用进行比较时，如果它们有相同的路径且指向同一个actor化身，则两者相等
- 指向一个已终止的actor的引用，与指向具有相同路径但却是另一个（重新创建）actor的引用是不相等的。
- 远程创建子 actor:
    - 逻辑地址: `akka.tcp://sys@A:2552/user/parrent/child`
    - 物理地址: `akka.tcp://sys@B:2552/remote/sys@A:2552/user/parrent/child`
- 在网络上传送actor引用时，是用它的路径来表示的. 因此，它的路径必须包括能够用来向它所代表的actor发送消息的完整信息。
- 当actor系统从远程节点接收到一个actor路径，会检查它的地址部分是否与自己的地址相同，如果相同，那么会将这条路径解析为本地actor引用，否则解析为一个远程actor引用。
- actor 路径的顶级作用域:
    - "/user" 是所有由用户创建的顶级actor的监管者；用 ActorSystem.actorOf创建的actor在其下。
    - "/system" 是所有由系统创建的顶级actor的监管者，如日志监听器，或由配置指定在actor系统启动时自动部署的actor。
    - "/deadLetters" 是死信actor，所有发往已经终止或不存在的actor的消息会被重定向到这里（以尽最大努力为基础：即使在本地JVM，消息也可能丢失）
    - "/temp"是所有系统创建的短时actor的监管者，例如那些在ActorRef.ask的实现中用到的actor。
    - "/remote" 是一个人造虚拟路径，用来存放所有其监管者是远程actor引用的actor。
- 在层次结构中的一切都是一个actor，所有的actor都以相同方式工作 (统一与一致)

## 位置透明性

- Akka中所有的东西都是被设计为在分布式环境下工作的：actor之间所有的互操作都是使用纯粹的消息传递机制，所有的操作都是异步的。
- “Akka中几乎没有为远程调用层设计的API”：而完全由配置来驱动
- Akka Remoting是以对等网络方式进行actor系统连接的通信模块，它是Akka集群的基础。远程处理的设计取决于两个（相关）的设计决策：
    - 涉及系统之间的通信是对称的：如果系统A可连接到系统B，那么B系统必须也能够独立连接到系统A。
    - 通信系统中的角色按照连接的模式是对称的：不存在系统只接受连接，也没有系统只发起连接。
- 一个actor系统除了可以在集群中的不同节点上运行不同的部分，还可以通过并行增加actor子树的方法来垂直扩展到多个cpu核上
